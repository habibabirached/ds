import React, { useState, useRef } from "react";
import { Line, Circle, Group, Rect, Text } from "react-konva";
import { minMax, dragBoundFunc } from "../utils";
import {
  defectLabels,
  defectColors,
  editMenu,
  editMenuColors,
  defectForeignObjectSubCat,
  defectSubmenuColors,
} from "../config";

let p = 2; // Some padding variable,

/**
 * PolygonAnnotation component is responsible for rendering and managing the annotation polygon.
 * It contains interactive elements like vertices, lines, and context menus for defect annotations.
 */
const PolygonAnnotation = (props) => {
  const {
    AI, // Boolean to determine if the polygon was generated by AI
    points, // Array of points that form the polygon
    polygonIndex, // Index of the polygon (  for tracking multiple polygons)
    flattenedPoints, // Array of points for rendering the line (flattened format)
    isFinished, // Boolean to check if the polygon is finalized or still editable
    color, // Color of the polygon
    makeInvisibleAnnotations, // Boolean to hide annotations (visibility toggle)
    defectName, // Name of the defect associated with this polygon
    handlePointDragMove, // Function to handle when a point (vertex) is dragged
    handleVertexUpdate, // Function to update vertex when dragged
    handleGroupDragEnd, // Function to handle the end of a group drag
    handleMouseOverStartPoint, // Function to handle mouse over the first vertex
    handleMouseOutStartPoint, // Function to handle mouse out of the first vertex
    isAnnotationMode, // Boolean to determine if we are in annotation mode
    onPolygonClick, // Function to handle click events on the polygon
  } = props;
  const vertexRadius = 3;

  // Utility function to determine if color is light
  const isLight = (color) => {
    // Convert hex color to RGB
    const hex = color.replace("#", "");
    const r = parseInt(hex.substr(0, 2), 16);
    const g = parseInt(hex.substr(2, 2), 16);
    const b = parseInt(hex.substr(4, 2), 16);

    // Calculate brightness
    const brightness = (r * 299 + g * 587 + b * 114) / 1000;
    return brightness > 100; // Threshold can be adjusted
  };

  const textColorAI = AI ? "red" : "white";

  const annotationColor = "transparent";
  const textColor = makeInvisibleAnnotations ? "transparent" : textColorAI;

  const textRefs = useRef([]); // Ref array to manage multiple text elements
  const contextMenuGroupRef = useRef(); // // Ref for the context menu (for Konva's group handling)

  const [hoveredMenuItem, setHoveredMenuItem] = useState("null"); // State to track which menu item is hovered
  const [submenuVisible, setSubmenuVisible] = useState(false);

  // State to track context menu visibility and position
  const [contextMenu, setContextMenu] = useState({
    visible: false,
    x: 0,
    y: 0,
  });

  const [isEditing, setIsEditing] = useState(false); // State to track if the polygon is in edit mode
  // const [editingPolygonIndex, setEditingPolygonIndex] = useState(null);

  // Function to calculate the centroid of the polygon
  const calculateCentroid = (points) => {
    let x = 0,
      y = 0;
    points.forEach((point) => {
      x += point[0];
      y += point[1];
    });
    return [x / points.length, y / points.length];
  };

  const centroid = calculateCentroid(points); // Calculate the centroid of the polygon

  // When a category is selected in the context menu
  const onSelectCategory = (category) => {
    props.onCategorySelect(category); // Call the function passed from Canvas
    setContextMenu({ ...contextMenu, visible: false }); // Hide the context menu
  };

  // onSelectCategory manages defect category selections for a polygon, while onSelectCategoryMenu handles
  // editing actions like "Erase." The former passes the selected defect category, and the latter passes
  // editing options to the parent component, with onSelectCategoryMenu also capable of triggering polygon
  //  removal. The key difference is that one handles defect categorization and the other manages editing actions.
  // When a category is selected in the context menu
  const onSelectCategoryMenu = (category) => {
    props.onCategorySelectMenu(category); // Call the function passed from Canvas
    setContextMenu({ ...contextMenu, visible: false }); // Hide the context menu
    if (category == "Erase") {
      props.erasePolygon(polygonIndex);
    }
  };

  // When the user right-clicks on a polygon, this function displays a custom context menu.
  // It first checks if the application is in annotation mode and disables the context menu if so.
  // The function calculates the appropriate X and Y coordinates for the menu, ensuring it doesn't go off the canvas edges.
  // Finally, it makes the context menu visible and brings it to the top layer to ensure proper display.
  // Function to display the context menu when user right-clicks
  const handleContextMenu = (e) => {
    if (isAnnotationMode) return; // Disable context menu in annotation mode
    console.log("I am in contextMenu");
    e.evt.preventDefault(); // Prevent the browser's default context menu from showing up
    let menuX = e.evt.layerX; // Get the X coordinate where the user clicked
    const menuY = 10; // Set a fixed Y position (could be made dynamic) becasue we want the menu to appear 10 pixels below the canvas top edge

    // Adjust menu position if too close to the right edge of the canvas
    let menuWidth = 300; // Menu width
    if (menuX > stage.width() - menuWidth - 10) {
      // Check if the cursor is near the right edge of the canvas
      menuX -= menuWidth + 10; //if yes,  Move the menu to the left side of the cursor
    }

    if (menuX < 100) {
      menuX = menuX + 90; // Adjust to the right if too close to the left
    }

    setContextMenu({ visible: true, x: menuX, y: menuY }); // Make context menu visible at the calculated position
    if (contextMenuGroupRef.current) {
      // Konva groups don't directly support zIndex, but you can adjust the zIndex of its layer
      // or manipulate the layer's children array to reorder elements
      const layer = contextMenuGroupRef.current.getLayer(); // Get the group layer
      // Move the context menu group to the top of its layer
      contextMenuGroupRef.current.moveToTop(); // Move context menu to top for visibility
      // Draw the layer again to apply changes
      layer.draw(); // Redraw the layer to apply the change
    }
  };

  const [stage, setStage] = useState(); // State to track the Konva stage (canvas reference)
  // This function is triggered when the mouse hovers over a polygon.
  // It first checks if the polygon is finished; if not, it exits early.
  // If the polygon is finished, it changes the cursor to a 'move' icon to indicate that the polygon can be dragged.
  // It also stores a reference to the current stage (canvas) for later use.
  const handleGroupMouseOver = (e) => {
    if (!isFinished) return;
    e.target.getStage().container().style.cursor = "move"; // Change cursor to move
    setStage(e.target.getStage()); // Set the stage reference
  };
  const handleGroupMouseOut = (e) => {
    e.target.getStage().container().style.cursor = "default"; // Reset cursor
  };
  // States to track the min and max positions on the X and Y axes
  //   minMaxX represents the minimum and maximum X values of these vertices, determining the leftmost and rightmost points of the polygon.
  // minMaxY represents the minimum and maximum Y values of these vertices, determining the topmost and bottommost points of the polygon.
  const [minMaxX, setMinMaxX] = useState([0, 0]); //min and max in x axis
  const [minMaxY, setMinMaxY] = useState([0, 0]); //min and max in y axis
  // Function to handle the start of a group drag event
  const handleGroupDragStart = (e) => {
    let arrX = points.map((p) => p[0]);
    let arrY = points.map((p) => p[1]);
    setMinMaxX(minMax(arrX));
    setMinMaxY(minMax(arrY));
  };
  const groupDragBound = (pos) => {
    let { x, y } = pos;
    const sw = stage.width();
    const sh = stage.height();
    if (minMaxY[0] + y < 0) y = -1 * minMaxY[0];
    if (minMaxX[0] + x < 0) x = -1 * minMaxX[0];
    if (minMaxY[1] + y > sh) y = sh - minMaxY[1];
    if (minMaxX[1] + x > sw) x = sw - minMaxX[1];
    return { x, y };
  };

  const handlePolygonClick = () => {
    console.log("polygon is clicked");
    onPolygonClick(props.polygonIndex);
  };

  return (
    <>
      {/* Group representing the polygon and its vertices */}
      <Group
        name="polygon"
        draggable={isFinished} // Allow dragging if polygon is finished
        onDragStart={handleGroupDragStart} // Handle drag start
        onDragEnd={handleGroupDragEnd} // Handle drag end
        dragBoundFunc={groupDragBound} // Limit dragging boundaries
        onMouseOver={handleGroupMouseOver} // Change cursor on mouse over
        onMouseOut={handleGroupMouseOut} // Reset cursor on mouse out
        onContextMenu={handleContextMenu} // Show context menu on right-click
        onClick={handlePolygonClick} // Handle click on polygon
      >
        {/* Line representing the polygon */}
        <Line
          points={flattenedPoints} // Flattened array of points for the polygon
          stroke={props.isSelected ? "green" : color || "#333333"} // Line color: green if selected, else the given color
          strokeWidth={2} // Line thickness
          closed={isFinished} // Close the shape if it's finished
          fill={annotationColor} // Fill color of the polygon
          onClick={() => {
            console.log("Polygon clicked!", {
              points,
              color,
              defectName,
              isFinished,
              polygonIndex,
            });
          }}
        />
        {defectName && (
          <Text
            text={defectName}
            x={centroid[0]}
            y={centroid[1]}
            // Style your text here
            fontSize={20}
            fontStyle={"bold"}
            fill={textColor}
            // Adjust alignment as needed
            align="center"
            verticalAlign="middle"
          />
        )}
        {points.map((point, index) => {
          const x = point[0] - vertexRadius / 2;
          const y = point[1] - vertexRadius / 2;
          const startPointAttr =
            index === 0
              ? {
                  hitStrokeWidth: 12,
                  onMouseOver: handleMouseOverStartPoint,
                  onMouseOut: handleMouseOutStartPoint,
                }
              : null;
          return (
            <Circle
              key={index}
              x={x}
              y={y}
              radius={vertexRadius}
              fill="#FF019A"
              stroke="#00F1FF"
              strokeWidth={2}
              draggable
              onDragMove={(e) => {
                // Calculate new position
                const newPos = [e.target.x(), e.target.y()];
                // Assuming props includes handleVertexUpdate and the index of the current polygon
                props.handleVertexUpdate(polygonIndex, index, newPos);
              }} // {handlePointDragMove}
              dragBoundFunc={(pos) =>
                dragBoundFunc(stage.width(), stage.height(), vertexRadius, pos)
              }
              {...startPointAttr}
            />
          );
        })}
      </Group>

      {/* Konva Context defect menu */}
      {contextMenu.visible && (
        <Group ref={contextMenuGroupRef} x={contextMenu.x} y={contextMenu.y}>
          {defectLabels.map((category, index) => {
            // Set a ref for each text item to measure its width
            const textRef = (el) => {
              textRefs.current[index] = el;
            };

            // Determine the fill color for each rectangle
            const fillColor = defectColors[index % defectColors.length]; //+ "99"; // Adding "99" for semi-transparency
            const textColor = isLight(fillColor) ? "#000" : "#FFF"; // Black text on light background, white on dark
            // Adjust for hovered item
            const isHovered = hoveredMenuItem === category;
            const menuItemStyle = isHovered
              ? { backgroundColor: "lightgreen" }
              : { backgroundColor: fillColor };
            const menuText = isHovered
              ? { textColor: "black" }
              : { textColor: textColor };
            return (
              <Group
                key={category}
                onClick={() => onSelectCategory(category)}
                onTap={() => onSelectCategory(category)} // For touch devices
                onMouseEnter={() => {
                  console.log(
                    "I am entering , at category  = ",
                    category,
                    " hovermenuItem = ",
                    hoveredMenuItem
                  );
                  setHoveredMenuItem(category);
                }}
                onMouseLeave={() => {
                  console.log(
                    "I am leaving , at category  = ",
                    category,
                    " hovermenuItem = ",
                    hoveredMenuItem
                  );
                  // setHoveredMenuItem(null); // Also hide the main menu hover state
                }}
              >
                {textRefs.current[index] && (
                  <Rect
                    x={-p}
                    y={(18 + 2 * p) * index}
                    width={300} // Adding some padding
                    height={18 + 2 * p}
                    fill={menuItemStyle.backgroundColor} // {fillColor}
                    //stroke="gray"
                  />
                )}
                <Text
                  ref={textRef}
                  x={0}
                  y={(18 + 2 * p) * index + p}
                  text={category}
                  fontSize={16}
                  fill={menuText.textColor}
                  onTransform={() => {
                    // Update the state to re-render if needed
                  }}
                />
              </Group>
            );
          })}
        </Group>
      )}

      {/* Konva Context Edit Menu */}
      {contextMenu.visible && (
        <Group x={contextMenu.x} y={contextMenu.y}>
          {editMenu.map((category, index) => {
            // Set a ref for each text item to measure its width
            const textRef = (el) => {
              textRefs.current[index] = el;
            };

            // Determine the fill color for each rectangle
            const fillColor = editMenuColors[index % editMenuColors.length]; //+ "99"; // Adding "99" for semi-transparency
            const textColor = isLight(fillColor) ? "#000" : "#FFF"; // Black text on light background, white on dark

            // Adjust for hovered item
            const isHovered = hoveredMenuItem === category;
            const menuItemStyle = isHovered
              ? { backgroundColor: "red" }
              : { backgroundColor: fillColor };
            const menuText = isHovered
              ? { textColor: "white" }
              : { textColor: textColor };

            return (
              <Group
                key={category}
                onClick={() => onSelectCategoryMenu(category)}
                onTap={() => onSelectCategoryMenu(category)} // For touch devices
                onMouseEnter={() => setHoveredMenuItem(category)}
                // onMouseLeave={() => setHoveredMenuItem(null)}
              >
                {textRefs.current[index] && (
                  <Rect
                    x={-p - 115}
                    y={(22 + 2 * p) * (index + 10)}
                    width={100} // Adding some padding
                    height={22 + 2 * p}
                    fill={menuItemStyle.backgroundColor}
                    //stroke="gray"
                  />
                )}
                <Text
                  ref={textRef}
                  x={-115}
                  y={(22 + 2 * p) * (10 + index) + p}
                  text={category}
                  fontSize={18}
                  fill={menuText.textColor}
                  onTransform={() => {
                    // Update the state to re-render if needed
                  }}
                />
              </Group>
            );
          })}
        </Group>
      )}

      {/* Konva Context Submenu for Foreign Objects */}
      {/* Konva Context Submenu for Foreign Objects */}
      {/* Konva Context Submenu for Foreign Objects */}
      {contextMenu.visible && (
        <Group
          x={contextMenu.x + 100}
          y={contextMenu.y}
          ref={(group) => {
            if (group) {
              group.moveToTop(); // Ensure submenu is moved to the top for visibility
            }
          }}
          onMouseEnter={() => setSubmenuVisible(true)} // Keep submenu visible
          onMouseLeave={() => {
            setSubmenuVisible(false); // Hide submenu when mouse leaves
            // setHoveredMenuItem(null); // Also hide the main menu hover state
          }}
        >
          {hoveredMenuItem &&
            hoveredMenuItem.includes("Foreign Objects") &&
            defectForeignObjectSubCat.map((subCategory, index) => {
              // Determine the fill color for each rectangle
              const fillColor =
                defectSubmenuColors[index % defectSubmenuColors.length]; //+ "99"; // Adding "99" for semi-transparency
              const textColor = isLight(fillColor) ? "#000" : "#FFF"; // Black text on light background, white on dark

              // checking what is hovered on
              const isHovered = hoveredMenuItem === subCategory;
              const menuItemStyle = isHovered
                ? { backgroundColor: "#005E60" }
                : { backgroundColor: fillColor };
              const menuText = isHovered
                ? { textColor: "white" }
                : { textColor: textColor };

              return (
                <Group
                  key={subCategory}
                  onClick={() => onSelectCategory(subCategory)}
                  onTap={() => onSelectCategory(subCategory)} // For touch devices
                  onMouseEnter={() => setHoveredMenuItem(subCategory)}
                  // onMouseLeave={() => setHoveredMenuItem(null)}
                >
                  <Rect
                    x={0}
                    y={(18 + 2 * p) * index}
                    width={480} // Width for the submenu items
                    height={18 + 2 * p}
                    fill={menuItemStyle.backgroundColor}
                  />
                  <Text
                    x={5} // Padding inside the submenu item
                    y={(18 + 2 * p) * index + p}
                    text={subCategory} // Submenu text
                    fontSize={16}
                    fill={menuText.textColor} // Text color
                  />
                </Group>
              );
            })}
        </Group>
      )}
    </>
  );
};

export default PolygonAnnotation;
